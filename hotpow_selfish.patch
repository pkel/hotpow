19c19
<   val progress : t -> block Link.t -> int
---
>   val progress : t -> ?other_only:bool -> block Link.t -> int
23a24,26
>   val my : t -> block Link.t -> vote list
>   (** Get own votes for lnk. *)
> 
85a89,94
>   let my t lnk =
>     match Hashtbl.find_opt t.ht lnk with
>     | None -> []
>     | Some votes ->
>         Set.elements votes.my |> List.map (fun e -> (lnk, e.id, e.s))
> 
87c96,97
<   (* Take leadership by omitting others' votes *)
---
> 
>   (* Maximize number of own votes *)
102,104c112,119
<           (* Consume merged votes into quorum of size t.q.size *)
<           let rec f n sum acc seq =
<             if n = t.q.size then Some (List.rev acc)
---
>           (* start from own votes, fill with smallest foreign votes until
>                complete *)
>           let rec fill n sum votes seq =
>             assert (n <= t.q.size) ;
>             if n = t.q.size && sum < t.q.size * t.q.threshold then
>               Some
>                 ( assert (Set.cardinal votes = t.q.size) ;
>                   Set.elements votes |> List.map (fun e -> (e.id, e.s)) )
108,112c123,133
<               | Cons (elt, tl) ->
<                   let sum = sum + elt.weight in
<                   if sum <= t.q.threshold * t.q.size then
<                     f (n + 1) sum ((elt.id, elt.s) :: acc) tl
<                   else None
---
>               | Cons (e, seq) ->
>                   let n, sum, votes =
>                     if n < t.q.size then
>                       (n + 1, sum + e.weight, Set.add e votes)
>                     else
>                       let max = Set.max_elt votes in
>                       ( n
>                       , sum + e.weight - max.weight
>                       , Set.(remove max votes |> add e) )
>                   in
>                   fill n sum votes seq
114c135,138
<           f 0 0 [] Set.(to_seq (union votes.my other))
---
>           let n = Set.cardinal votes.my
>           and sum = Set.fold (fun e sum -> sum + e.weight) votes.my 0
>           and seq = Set.to_seq other in
>           fill n sum votes.my seq
124c148
<   let progress t lnk =
---
>   let progress t ?(other_only = false) lnk =
135c159,162
<         f 0 0 Set.(to_seq (union votes.my votes.other) ())
---
>         let incl =
>           if other_only then votes.other else Set.union votes.my votes.other
>         in
>         f 0 0 Set.(to_seq incl ())
379c406,415
<     if not (propose ~replace:true lnk) then Broadcast.send (Vote vote)
---
>     (* If own votes cannot be released as block proposal, but foreign nodes
>        are about to propose a block without our votes, then release all
>        votes *)
>     if
>       (not (propose ~replace:false lnk))
>       && Poll.progress ~other_only:true poll lnk >= quorum_size - 1
>     then
>       List.iter
>         (fun v -> Broadcast.send (Vote v))
>         (Poll.my poll lnk |> List.rev)
