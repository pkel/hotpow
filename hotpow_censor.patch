83c83
<   (* Take leadership by omitting others' votes *)
---
>   (* Maximize number of own votes *)
98,100c98,105
<           (* Consume merged votes into quorum of size t.q.size *)
<           let rec f n sum acc seq =
<             if n = t.q.size then Some (List.rev acc)
---
>           (* start from own votes, fill with smallest foreign votes until
>                complete *)
>           let rec fill n sum votes seq =
>             assert (n <= t.q.size) ;
>             if n = t.q.size && sum < t.q.size * t.q.threshold then
>               Some
>                 ( assert (Set.cardinal votes = t.q.size) ;
>                   Set.elements votes |> List.map (fun e -> (e.id, e.s)) )
104,108c109,119
<               | Cons (elt, tl) ->
<                   let sum = sum + elt.weight in
<                   if sum <= t.q.threshold * t.q.size then
<                     f (n + 1) sum ((elt.id, elt.s) :: acc) tl
<                   else None
---
>               | Cons (e, seq) ->
>                   let n, sum, votes =
>                     if n < t.q.size then
>                       (n + 1, sum + e.weight, Set.add e votes)
>                     else
>                       let max = Set.max_elt votes in
>                       ( n
>                       , sum + e.weight - max.weight
>                       , Set.(remove max votes |> add e) )
>                   in
>                   fill n sum votes seq
110c121,124
<           f 0 0 [] Set.(to_seq (union votes.my other))
---
>           let n = Set.cardinal votes.my
>           and sum = Set.fold (fun e sum -> sum + e.weight) votes.my 0
>           and seq = Set.to_seq other in
>           fill n sum votes.my seq
365c379
<     if not (propose ~replace:true lnk) then Broadcast.send (Vote vote)
---
>     ignore (propose ~replace:false lnk)
